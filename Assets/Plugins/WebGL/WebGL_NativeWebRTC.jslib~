var WebGL_NativeWebRTC = {
    $webgl_o: {
        signalingServerUrl: null,
        sendWidth: 0,
        sendHeight: 0,
        sendTexture: null,
        ws: null,
        texPtr: null,
        pc: null,
        video: null,
        canRead: null,
        buffer: null,
        frameBuffer: null,
        cnv: null,
        ctx: null,
        imageData: null,
        dlgOnLocalVideoTrackCreated: null,
        dlgOnRemoteVideoTrackGenerated: null
    },

    WebGL_Setup: function (
        signalingServerUrlPtr,
        sendWidth,
        sendHeight,
        sendTexturePtr,
        dlgOnLocalVideoTrackCreated,
        dlgOnRemoteVideoTrackGenerated
    ) {
        console.log('=-== Setup');
        webgl_o.signalingServerUrl = UTF8ToString(signalingServerUrlPtr);
        webgl_o.sendWidth = sendWidth;
        webgl_o.sendHeight = sendHeight;
        webgl_o.sendTexture = GL.textures[sendTexturePtr];
        webgl_o.buffer = new Uint8Array(sendWidth * sendHeight * 4);
        webgl_o.dlgOnLocalVideoTrackCreated = dlgOnLocalVideoTrackCreated;
        webgl_o.dlgOnRemoteVideoTrackGenerated = dlgOnRemoteVideoTrackGenerated;
    },

    WebGL_Connect__deps: [
        '$WebGL_SignalingSendMessage', 
        '$WebGL_CreatePeer', 
        '$WebGL_CreateVideoTrack'
    ],
    WebGL_Connect: function () {
        console.log('=-== Connect');
        webgl_o.ws = new WebSocket(webgl_o.signalingServerUrl);
        webgl_o.pc = null;
        
        webgl_o.ws.onopen = function () {
            console.log('=-== SignalingServer Connected');
        };
        
        webgl_o.ws.onerror = function (error) {
            console.error('=-== WebSocket Error:', error);
        };
        
        webgl_o.ws.onclose = function () {
            console.log('=-== WebSocket Closed');
        };
        
        webgl_o.ws.onmessage = async function (evt) {
            try {
                var msg = JSON.parse(evt.data);
                
                if (webgl_o.pc === null) {
                    _WebGL_CreatePeer();
                }
                
                if (msg.sdp) {
                    console.log('=-== SetRemoteDescription: ' + msg.type);
                    await webgl_o.pc.setRemoteDescription(new RTCSessionDescription(msg));
                    
                    if (msg.type === 'offer') {
                        const answer = await webgl_o.pc.createAnswer();
                        await webgl_o.pc.setLocalDescription(answer);
                        SignalingSendMessage(webgl_o.pc.localDescription);
                    }
                } else if (msg.candidate) {
                    console.log('=-== Adding ICE Candidate');
                    await webgl_o.pc.addIceCandidate(new RTCIceCandidate(msg));
                }
            } catch (error) {
                console.error('=-== Error handling message:', error);
            }
        };
    },

    $WebGL_SignalingSendMessage: function (msg) {
        if (webgl_o.ws && webgl_o.ws.readyState === WebSocket.OPEN) {
            var json = JSON.stringify(msg);
            webgl_o.ws.send(json);
            console.log('=-== Sent message:', msg.type);
        } else {
            console.error('=-== WebSocket not ready to send message');
        }
    },

    $WebGL_CreatePeer: function () {
        console.log('=-== CreatePC');
        
        webgl_o.pc = new RTCPeerConnection({
            iceServers: [
                { urls: "stun:stun.l.google.com:19302" },
                { urls: "stun:stun1.l.google.com:19302" }
            ]
        });
        
        webgl_o.pc.onicecandidate = function (evt) {
            if (evt.candidate) {
                console.log('=-== webgl_o. ICE Candidate');
                SignalingSendMessage({
                    type: 'candidate',
                    candidate: evt.candidate.candidate,
                    sdpMid: evt.candidate.sdpMid,
                    sdpMLineIndex: evt.candidate.sdpMLineIndex
                });
            } else {
                console.log('=-== ICE Gathering Complete');
            }
        };
        
        webgl_o.pc.oniceconnectionstatechange = function () {
            console.log('=-== ICE Connection State:', webgl_o.pc.iceConnectionState);
        };
        
        webgl_o.pc.onconnectionstatechange = function () {
            console.log('=-== Connection State:', webgl_o.pc.connectionState);
        };
        
        webgl_o.pc.ontrack = function (evt) {
            console.log('=-== webgl_o. Track: ' + evt.track.kind);
            
            if (evt.track.kind === 'video') {
                webgl_o.video = document.createElement('video');
                webgl_o.video.autoplay = true;
                webgl_o.video.muted = true;
                webgl_o.video.playsInline = true;
                
                webgl_o.video.onloadedmetadata = function () {
                    console.log('=-== Video metadata loaded: ' + webgl_o.video.videoWidth + 'x' + webgl_o.video.videoHeight);
                    {{{makeDynCall('vii')}}}(
                        webgl_o.dlgOnRemoteVideoTrackGenerated,
                        webgl_o.video.videoWidth,
                        webgl_o.video.videoHeight
                    );
                };
                
                webgl_o.video.onresize = function () {
                    console.log('=-== Video resized: ' + webgl_o.video.videoWidth + 'x' + webgl_o.video.videoHeight);
                    {{{makeDynCall('vii')}}}(
                        webgl_o.dlgOnRemoteVideoTrackGenerated,
                        webgl_o.video.videoWidth,
                        webgl_o.video.videoHeight
                    );
                };
                
                webgl_o.video.srcObject = new MediaStream([evt.track]);
                webgl_o.video.play().catch(function(error) {
                    console.error('=-== Video play error:', error);
                });
            }
        };
        
        CreateVideoTrack();
        {{{makeDynCall('v')}}}(webgl_o.dlgOnLocalVideoTrackCreated);
    },

    $WebGL_CreateVideoTrack: function () {
        console.log('=-== CreateVideoTrack');
        
        webgl_o.cnv = document.createElement('canvas');
        webgl_o.cnv.width = webgl_o.sendWidth;
        webgl_o.cnv.height = webgl_o.sendHeight;
        webgl_o.ctx = webgl_o.cnv.getContext('2d', { alpha: false });
        webgl_o.imageData = webgl_o.ctx.createImageData(webgl_o.sendWidth, webgl_o.sendHeight);
        
        // Capture stream at specific frame rate
        var stream = webgl_o.cnv.captureStream(30); // 30 fps
        var track = stream.getVideoTracks()[0];
        
        webgl_o.pc.addTrack(track, stream);
        console.log('=-== Video track added to peer connection');
    },

    WebGL_RenderLocalVideoTrack: function () {
        try {
            // Create temporary framebuffer to read texture data
            var fb = GLctx.createFramebuffer();
            GLctx.bindFramebuffer(GLctx.FRAMEBUFFER, fb);
            GLctx.framebufferTexture2D(
                GLctx.FRAMEBUFFER,
                GLctx.COLOR_ATTACHMENT0,
                GLctx.TEXTURE_2D,
                webgl_o.sendTexture,
                0
            );
            
            // Check if framebuffer is complete
            var status = GLctx.checkFramebufferStatus(GLctx.FRAMEBUFFER);
            if (status !== GLctx.FRAMEBUFFER_COMPLETE) {
                console.error('=-== Framebuffer not complete:', status);
                GLctx.bindFramebuffer(GLctx.FRAMEBUFFER, null);
                GLctx.deleteFramebuffer(fb);
                return;
            }
            
            // Read pixels from texture
            GLctx.readPixels(
                0, 0,
                webgl_o.sendWidth, webgl_o.sendHeight,
                GLctx.RGBA,
                GLctx.UNSIGNED_BYTE,
                webgl_o.buffer
            );
            
            // Cleanup
            GLctx.bindFramebuffer(GLctx.FRAMEBUFFER, null);
            GLctx.deleteFramebuffer(fb);
            
            // Update canvas
            webgl_o.imageData.data.set(webgl_o.buffer);
            webgl_o.ctx.putImageData(webgl_o.imageData, 0, 0);
            
        } catch (error) {
            console.error('=-== RenderLocalVideoTrack error:', error);
        }
    },

    WebGL_RenderRemoteVideoTrack: function (texPtr) {
        if (!webgl_o.video || webgl_o.video.readyState < 2) {
            // Video not ready yet
            return;
        }
        
        try {
            var tex = GL.textures[texPtr];
            GLctx.bindTexture(GLctx.TEXTURE_2D, tex);
            GLctx.pixelStorei(GLctx.UNPACK_FLIP_Y_WEBGL, true);
            
            // Use texSubImage2D for immutable textures
            // This avoids the GL_INVALID_OPERATION error
            GLctx.texSubImage2D(
                GLctx.TEXTURE_2D,
                0,
                0, 0,
                GLctx.RGBA,
                GLctx.UNSIGNED_BYTE,
                webgl_o.video
            );
            
            // Set texture parameters
            GLctx.texParameteri(GLctx.TEXTURE_2D, GLctx.TEXTURE_MAG_FILTER, GLctx.LINEAR);
            GLctx.texParameteri(GLctx.TEXTURE_2D, GLctx.TEXTURE_MIN_FILTER, GLctx.LINEAR);
            GLctx.texParameteri(GLctx.TEXTURE_2D, GLctx.TEXTURE_WRAP_S, GLctx.CLAMP_TO_EDGE);
            GLctx.texParameteri(GLctx.TEXTURE_2D, GLctx.TEXTURE_WRAP_T, GLctx.CLAMP_TO_EDGE);
            
            GLctx.bindTexture(GLctx.TEXTURE_2D, null);
            
        } catch (error) {
            console.error('=-== RenderRemoteVideoTrack error:', error);
        }
    },

    WebGL_Disconnect: function () {
        console.log('=-== Disconnect');
        
        if (webgl_o.pc) {
            webgl_o.pc.close();
            webgl_o.pc = null;
        }
        
        if (webgl_o.ws) {
            webgl_o.ws.close();
            webgl_o.ws = null;
        }
        
        if (webgl_o.video) {
            webgl_o.video.srcObject = null;
            webgl_o.video = null;
        }
        
        if (webgl_o.cnv) {
            var stream = webgl_o.cnv.captureStream();
            stream.getTracks().forEach(function(track) {
                track.stop();
            });
            webgl_o.cnv = null;
        }
        
        webgl_o.ctx = null;
        webgl_o.imageData = null;
    },

    WebGL_GetConnectionState: function () {
        if (!webgl_o.pc) return 0; // Disconnected
        
        switch (webgl_o.pc.connectionState) {
            case 'new': return 1;
            case 'connecting': return 2;
            case 'connected': return 3;
            case 'disconnected': return 4;
            case 'failed': return 5;
            case 'closed': return 0;
            default: return 0;
        }
    }
};

autoAddDeps(WebGL_NativeWebRTC, '$webgl_o');
mergeInto(LibraryManager.library, WebGL_NativeWebRTC);